<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Story Tree Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    *{box-sizing:border-box;}
    body {
      margin: 0;
      background: #0f111a;
      color: #e3e8ff;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow: hidden;
    }
    header {
      padding: 12px 18px;
      background: #1f2435;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }
    h1 {
      margin: 0;
      font-size: 1.5rem;
      flex: 1;
    }
    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .btn {
      background: #6366f1;
      border: none;
      padding: 8px 14px;
      border-radius: 8px;
      cursor: pointer;
      color: #fff;
      font-weight: 600;
      font-size: 13px;
    }
    .container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    #svgContainer {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg,#1a1f3a,#0f111a);
      cursor: grab;
    }
    #detailPanel {
      width: 360px;
      min-width: 280px;
      background: #1f2435;
      padding: 16px;
      border-left: 1px solid rgba(255,255,255,.08);
      overflow: auto;
    }
    .node-square {
      cursor: pointer;
      stroke: #6366f1;
      fill: #1b1f44;
      filter: drop-shadow(0 10px 20px rgba(99,102,241,.4));
    }
    .node-label {
      pointer-events: none;
      font-size: 12px;
      fill: #f0f5ff;
      font-weight: 600;
    }
    .choice-label {
      font-size: 10px;
      fill: #c0c7ff;
    }
    .highlight {
      stroke: #f9d423;
      stroke-width: 3px;
    }
    .small {
      font-size: 12px;
      color: #97a0c3;
    }
    .choice-btn {
      background: #2f3360;
      border: none;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      margin: 4px 2px;
      color: #fff;
      font-size: 13px;
    }
    code {
      background: rgba(255,255,255,.05);
      padding: 2px 4px;
      border-radius: 4px;
    }
    .legend {
      margin-top: 8px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
    }
    .square-sample {
      width: 12px;
      height: 12px;
      background: #1b1f44;
      border: 2px solid #6366f1;
      border-radius: 3px;
    }
    .status {
      margin-right: 8px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Story Tree</h1>
    <div class="controls">
      <div class="status">Use mouse wheel to zoom, drag to pan, double-click to reset.</div>
      <button class="btn" id="fitBtn">Center & Fit</button>
    </div>
  </header>
  <div class="container">
    <div id="svgContainer">
      <svg id="treeSvg" xmlns="http://www.w3.org/2000/svg" width="1600" height="1200" style="touch-action: none; user-select:none;"></svg>
    </div>
    <div id="detailPanel">
      <div id="detail"><div class="small">Load a node by clicking its square or following a choice.</div></div>
      <div class="legend">
        <div class="legend-item"><div class="square-sample"></div> Node</div>
        <div class="legend-item"><div style="width:12px;height:2px;background:#888;margin-right:4px;"></div> Branch</div>
        <div class="legend-item"><div style="width:12px;height:2px;background:#f9d423;margin-right:4px;"></div> Highlighted</div>
      </div>
    </div>
  </div>

  <script>
    let story = null;
    const svg = document.getElementById("treeSvg");
    const svgContainer = document.getElementById("svgContainer");
    const detailEl = document.getElementById("detail");
    const fitBtn = document.getElementById("fitBtn");

    const NODE_SIZE = 100;
    const H_SPACING = 60;
    const V_SPACING = 140;
    const positions = {};
    let transform = {x:0, y:0, k:1};

    async function loadStory() {
      try {
        const res = await fetch("story.json");
        if (!res.ok) throw new Error("Failed to fetch story.json: " + res.statusText);
        story = await res.json();
        buildAndRender();
        attachInteraction();
      } catch (e) {
        detailEl.innerHTML = `<div style="color:tomato;">${e.message}</div>`;
      }
    }

    function buildAndRender() {
      if (!story) return;

      const levels = {};
      const visited = new Set();
      const collect = (key, depth=0) => {
        if (visited.has(key)) return;
        visited.add(key);
        if (!levels[depth]) levels[depth] = [];
        levels[depth].push(key);
        const node = story[key];
        if (node && node.choices) {
          node.choices.forEach(c => collect(c.next, depth+1));
        }
      };
      collect("start");

      const maxNodes = Math.max(...Object.values(levels).map(arr => arr.length));

      Object.entries(levels).forEach(([depth, keys]) => {
        const rowWidth = keys.length * (NODE_SIZE + H_SPACING) - H_SPACING;
        const totalWidth = maxNodes * (NODE_SIZE + H_SPACING) - H_SPACING;
        const offsetX = (totalWidth - rowWidth) / 2;
        keys.forEach((key, i) => {
          const x = offsetX + i * (NODE_SIZE + H_SPACING);
          const y = depth * V_SPACING;
          positions[key] = {x, y};
        });
      });

      let maxX = 0, maxY = 0;
      Object.values(positions).forEach(({x,y}) => {
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      });
      const width = maxX + NODE_SIZE + 200;
      const height = maxY + NODE_SIZE + 200;
      svg.setAttribute("width", width);
      svg.setAttribute("height", height);
      svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
      svg.innerHTML = "";

      Object.entries(story).forEach(([key, node]) => {
        if (!node || !node.choices) return;
        const from = positions[key];
        if (!from) return;
        node.choices.forEach(c => {
          const to = positions[c.next];
          if (!to) return;
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          const startX = from.x + NODE_SIZE / 2;
          const startY = from.y + NODE_SIZE;
          const endX = to.x + NODE_SIZE / 2;
          const endY = to.y;
          const d = `
            M ${startX} ${startY}
            C ${startX} ${startY + 30} ${endX} ${endY - 30} ${endX} ${endY}
          `;
          path.setAttribute("d", d.trim());
          path.setAttribute("fill", "none");
          path.setAttribute("stroke", "rgba(255,255,255,.2)");
          path.setAttribute("stroke-width", "2");
          svg.appendChild(path);
          if (c.text) {
            const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
            label.setAttribute("class", "choice-label");
            label.textContent = c.text;
            const labelX = (startX + endX) / 2;
            const labelY = (startY + endY) / 2 - 6;
            label.setAttribute("x", labelX);
            label.setAttribute("y", labelY);
            label.setAttribute("text-anchor", "middle");
            svg.appendChild(label);
          }
        });
      });

      Object.entries(positions).forEach(([key, pos]) => {
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        group.dataset.key = key;
        group.setAttribute("transform", `translate(${pos.x},${pos.y})`);

        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("width", NODE_SIZE);
        rect.setAttribute("height", NODE_SIZE);
        rect.setAttribute("rx", "8");
        rect.setAttribute("ry", "8");
        rect.setAttribute("class", "node-square");
        rect.setAttribute("stroke-width", "2");
        group.appendChild(rect);

        const title = document.createElementNS("http://www.w3.org/2000/svg", "text");
        title.setAttribute("x", NODE_SIZE / 2);
        title.setAttribute("y", 20);
        title.setAttribute("text-anchor", "middle");
        title.setAttribute("class", "node-label");
        title.textContent = key;
        group.appendChild(title);

        const node = story[key];
        if (node && (!node.choices || node.choices.length === 0)) {
          const endBadge = document.createElementNS("http://www.w3.org/2000/svg", "text");
          endBadge.setAttribute("x", NODE_SIZE - 6);
          endBadge.setAttribute("y", NODE_SIZE - 8);
          endBadge.setAttribute("text-anchor", "end");
          endBadge.setAttribute("class", "choice-label");
          endBadge.textContent = "END";
          group.appendChild(endBadge);
        }

        group.addEventListener("click", (e) => {
          e.stopPropagation();
          clearHighlights();
          rect.classList.add("highlight");
          showDetail(key, []);
        });

        svg.appendChild(group);
      });

      requestAnimationFrame(() => {
        fitToViewport();
        highlightNode("start");
        showDetail("start", []);
      });
    }

    function clearHighlights() {
      svg.querySelectorAll("rect").forEach(r => r.classList.remove("highlight"));
    }

    function highlightNode(key) {
      clearHighlights();
      const g = svg.querySelector(`g[data-key="${key}"]`);
      if (!g) return;
      const rect = g.querySelector("rect");
      if (rect) rect.classList.add("highlight");
    }

    function showDetail(key, path) {
      const node = story[key];
      if (!node) {
        detailEl.innerHTML = `<div style="color:tomato;">Node "${key}" not found.</div>`;
        return;
      }
      highlightNode(key);
      let html = `<h2 style="margin-top:0;">${key}</h2>`;
      html += `<div class="small">Lines:</div>`;
      html += `<div style="margin:6px 0;padding:8px;background:rgba(255,255,255,.03);border-radius:6px;">`;
      node.lines.forEach(l => {
        html += `<div><span style="font-weight:600;">${escapeHTML(l.character)}:</span> ${escapeHTML(l.text)}</div>`;
      });
      html += `</div>`;

      if (node.choices && node.choices.length) {
        html += `<div class="small">Choices:</div>`;
        node.choices.forEach(c => {
          html += `<button class="choice-btn" data-next="${c.next}" data-text="${escapeHTML(c.text)}">${escapeHTML(c.text)}</button>`;
        });
      } else {
        html += `<div style="margin-top:6px;">This is an ending node (no further choices).</div>`;
      }

      if (node.affinityReq || node.affinityChange) {
        html += `<div style="margin-top:8px;">`;
        if (node.affinityReq) {
          const reqs = Object.entries(node.affinityReq).map(([k,v]) => `${k} â‰¥ ${v}`).join(", ");
          html += `<div class="small">Affinity Requirements: ${escapeHTML(reqs)}</div>`;
        }
        if (node.affinityChange) {
          const changes = Object.entries(node.affinityChange).map(([k,v]) => {
            const sign = v >= 0 ? "+"+v : v;
            return `${k}${sign}`;
          }).join(", ");
          html += `<div class="small">Affinity Changes: ${escapeHTML(changes)}</div>`;
        }
        html += `</div>`;
      }

      detailEl.innerHTML = html;

      detailEl.querySelectorAll(".choice-btn").forEach(btn => {
        btn.addEventListener("click", () => {
          const next = btn.dataset.next;
          const text = btn.dataset.text;
          showDetail(next, [...path, {from: key, choice: text}]);
          highlightNode(next);
          centerOnNode(next);
        });
      });
    }

    function escapeHTML(str) {
      return str.replace(/[&<>"']/g, m => ({
        "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;"
      }[m]));
    }

    function attachInteraction() {
      let isPanning = false;
      let start = {x:0,y:0};
      const svgRoot = svg;

      const applyTransform = () => {
        const {k,x,y} = transform;
        svgRoot.style.transform = `translate(${x}px,${y}px) scale(${k})`;
      };

      svgContainer.addEventListener("wheel", (e) => {
        e.preventDefault();
        const rect = svgContainer.getBoundingClientRect();
        const offsetX = e.clientX - rect.left;
        const offsetY = e.clientY - rect.top;
        const scaleAmount = Math.exp(-e.deltaY * 0.002);
        const prevK = transform.k;
        transform.k = Math.min(4, Math.max(0.2, transform.k * scaleAmount));
        transform.x -= (offsetX / prevK - offsetX / transform.k);
        transform.y -= (offsetY / prevK - offsetY / transform.k);
        applyTransform();
      }, {passive:false});

      svgContainer.addEventListener("mousedown", (e) => {
        isPanning = true;
        svgContainer.style.cursor = "grabbing";
        start = {x: e.clientX - transform.x, y: e.clientY - transform.y};
      });
      window.addEventListener("mousemove", (e) => {
        if (!isPanning) return;
        transform.x = e.clientX - start.x;
        transform.y = e.clientY - start.y;
        applyTransform();
      });
      window.addEventListener("mouseup", () => {
        isPanning = false;
        svgContainer.style.cursor = "grab";
      });

      svgContainer.addEventListener("dblclick", (e) => {
        fitToViewport();
      });

      fitBtn.addEventListener("click", fitToViewport);
    }

    function fitToViewport() {
      const containerRect = svgContainer.getBoundingClientRect();
      const svgBBox = svg.getBBox();
      const margin = 40;
      const scaleX = (containerRect.width - margin) / svgBBox.width;
      const scaleY = (containerRect.height - margin) / svgBBox.height;
      const scale = Math.min(scaleX, scaleY, 1.5);
      transform.k = scale;
      const targetWidth = svgBBox.width * transform.k;
      const targetHeight = svgBBox.height * transform.k;
      transform.x = (containerRect.width - targetWidth) / 2 - svgBBox.x * transform.k;
      transform.y = (containerRect.height - targetHeight) / 2 - svgBBox.y * transform.k;
      applyTransform();
    }

    function centerOnNode(key) {
      const group = svg.querySelector(`g[data-key="${key}"]`);
      if (!group) return;
      const bbox = group.getBBox();
      const containerRect = svgContainer.getBoundingClientRect();
      const centerX = bbox.x + bbox.width / 2;
      const centerY = bbox.y + bbox.height / 2;
      transform.x = containerRect.width / 2 - centerX * transform.k;
      transform.y = containerRect.height / 2 - centerY * transform.k;
      applyTransform();
    }

    loadStory();
  </script>
</body>
</html>
